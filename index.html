<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Pong — Single-file PWA</title>

  <!-- Inline manifest as a data URL (single-file) -->
  <!-- NOTE: replace the tiny placeholder icon if you want a proper app icon -->
  <link rel="manifest"
        href="data:application/json;base64,eyJuYW1lIjoiUG9uZyBQV0EiLCJzaG9ydF9uYW1lIjoiUG9uZyIsInN0YXJ0X3VybCI6Ii4iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjMGQwZDAiLCJ0aGVtZV9jb2xvciI6IiMwZDBkZDAiLCJpY29ucyI6W3sic3JjIjoiZGF0YTp
pbWFnZS9wbmc7YmFzZTY0LGlWSk9SdzBLS2dvQUFBQU5TRXZnSkFBQUVBVUFDMUhhVXdDQUFBQjNMRVFWMHJHTXln
WDk9Iiwic2l6ZXMiOiIxOTJ4MTkyIiwidHlwZSI6ImltYWdlL3BuZyIsInB1cnBvc2UiOiJhbnkifV19">
  <meta name="theme-color" content="#0d0d0d" />

  <!-- iOS home screen icon (placeholder transparent PNG). Replace with base64 PNG for full effect. -->
  <link rel="apple-touch-icon" href="https://lh3.googleusercontent.com/rd-d/ALs6j_GZ7uuY0CGtpxeudhYhcokTsNLaZFowkEcdFYira2tGrL-4jh2Lnm2rr46WeZ4fH_iyqAqLcWUvm4JKppEqOsn_WCCAh7mow_L1rwI7pFXkv7KlRuHrUfr2r1yCW1KgfNJrcoJA_mgX9Cpm7Z6eDW0LIp8kPt0YIKW7nqLuzZWoiOdNxiWj5h7Ns8lwXFsIH3jE-h9chbEM2QZbcfqFmj3cxOvgvZiPRHjG8MdLrOtQjPqc3ZHhIaaL1Rr9SgWatce6qTIjX5Q3j4g5kH18WcnrkqQ2G90qcIK6CDFdhlU8WUCuJwrmIOecQxhXvdU9OyFp8vfTZsnWrsiqTsklE8uWxvlM6PfeUWXiBH1RmaErEmWTTtlgk_bn45i1ucDg4CIoJeNtzqak2_ObIGRMrBGWG7eGX8v9mZ8haxi_vayjp2lWXo2VcH2iOuKsXihlDRv0AA30lCIpwoYsFlpdNFz9buHlJVdRsX7Bbyi82ISfPJ3aFPALBo4K3aC9F_GZ5cmcLnLfgly-X-bO98RP5M3TkuR_raO9CYcQ122X5QRUIWlrZTwvepiDhnatOnn35YskUYQdAVEnFWw3WDq19y5MEyIUcNZf2Xgc4XSWM7pyhEUtY9ql9N6vPvCHgkoFmZiRfjUc-hS8gFsfiB_RFvAhumQL3muNAIGMj948PpmKi9YvshYPG5hmGoMglfmxCLoSvF-zn36cI1hIfxG3PnxbO3K2aDUsKaergiHbZ-Z6AUPhXDE_h643FAUrUJib-yFel45k6EhF-y5mYkIWHkU7CPNdxYiU4N7293C662IwsiBYkJ4gA7NO7fQomzcN5i8doJZBkCb616WEvWniepa_hKs9bPx1BILJKu5_jbmKx0mDCZ48rFkqJ3H1CkzA_LkWtTzsUbA2-TFNaoXnMOw-sf-njWisiEo5MrND_ilUjrj-NUY4n7AA7oBm0b1-kHuoE0sDqPD2hq205jdXbQ_9DQFc=w2940-h1602?auditContext=prefetch=">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    :root{ --bg:#0d0d0d; --fg:#eaeaea; --muted:#9a9a9a; }
    html,body{ height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background:var(--bg); color:var(--fg); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    #app{ display:flex; flex-direction:column; min-height:100vh; align-items:center; justify-content:flex-start; gap:12px; padding:12px; box-sizing:border-box; }
    header{ width:100%; max-width:900px; display:flex; justify-content:space-between; align-items:center; gap:8px; }
    h1{ margin:0; font-size:1.05rem; font-weight:600; }
    .controls button{ margin-left:8px; padding:6px 8px; background:transparent; color:var(--fg); border:1px solid #222; border-radius:6px; cursor:pointer; }
    .game-wrap{ width:100%; max-width:900px; flex:1 1 auto; display:flex; flex-direction:column; align-items:center; gap:8px; }
    canvas{ width:100%; height:60vh; background:#000; border-radius:8px; box-shadow:0 8px 30px rgba(0,0,0,0.6); touch-action:none; display:block; }
    .scoreboard{ color:var(--muted); font-size:1.05rem; display:flex; gap:12px; align-items:center; }
    footer{ color:var(--muted); font-size:0.85rem; text-align:center; max-width:900px; }
    .controls { display:flex; align-items:center; gap:6px; }
    #installBtn { display:none; }
  </style>
</head>
<body>
  <main id="app">
    <header>
      <h1>Pong — Single-file PWA</h1>
      <div class="controls">
        <button id="btn-toggle-ai">AI: ON</button>
        <button id="btn-pause">Pause</button>
        <button id="btn-reset">Reset Scores</button>
        <button id="installBtn">Install</button>
      </div>
    </header>

    <section class="game-wrap">
      <canvas id="game" width="900" height="600"></canvas>
      <div class="scoreboard">
        <span id="score-left">0</span>
        <span>—</span>
        <span id="score-right">0</span>
      </div>
    </section>

    <footer>
      <small>Use W/S or ↑/↓ to move left paddle. On mobile: touch & drag left/right half to move the respective paddle.</small>
    </footer>
  </main>

  <script>
  (function () {
    'use strict';

    /* ---------------------------
       Service worker (inline via Blob)
       --------------------------- */
    const swCode = `
      const CACHE_NAME = 'pong-pwa-v1';
      const OFFLINE_PAGE = location.pathname;
      self.addEventListener('install', event => {
        event.waitUntil(
          caches.open(CACHE_NAME).then(cache => {
            // Cache only the HTML page (single-file) so app loads offline
            return cache.addAll([OFFLINE_PAGE]);
          })
        );
        self.skipWaiting();
      });
      self.addEventListener('activate', event => {
        event.waitUntil(self.clients.claim());
      });
      self.addEventListener('fetch', event => {
        // Network-first for navigation requests (so updates are fetched), fall back to cache
        if (event.request.mode === 'navigate' || (event.request.method === 'GET' && event.request.headers.get('accept')?.includes('text/html'))) {
          event.respondWith(
            fetch(event.request).then(resp => {
              // update cache
              const copy = resp.clone();
              caches.open(CACHE_NAME).then(c => c.put(event.request, copy));
              return resp;
            }).catch(() => caches.match(OFFLINE_PAGE))
          );
          return;
        }
        // For everything else, try cache then network
        event.respondWith(
          caches.match(event.request).then(cached => cached || fetch(event.request).catch(() => cached))
        );
      });
    `;
    if ('serviceWorker' in navigator) {
      try {
        const swBlob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(swBlob);
        navigator.serviceWorker.register(swUrl, { scope: './' }).then(reg => {
          console.log('Service Worker registered (from blob).', reg);
        }).catch(err => {
          console.warn('Service Worker registration failed:', err);
        });
      } catch (e) {
        console.warn('SW blob registration not supported:', e);
      }
    }

    /* ---------------------------
       PWA install prompt handling
       --------------------------- */
    let deferredPrompt = null;
    const installBtn = document.getElementById('installBtn');
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBtn.style.display = 'inline-block';
    });
    installBtn.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      const choice = await deferredPrompt.userChoice;
      console.log('A2HS choice:', choice);
      deferredPrompt = null;
      installBtn.style.display = 'none';
    });

    /* ---------------------------
       Game implementation (compact, robust)
       --------------------------- */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });

    // scoreboard elements
    const scoreLeftEl = document.getElementById('score-left');
    const scoreRightEl = document.getElementById('score-right');
    const btnPause = document.getElementById('btn-pause');
    const btnToggleAI = document.getElementById('btn-toggle-ai');
    const btnReset = document.getElementById('btn-reset');

    // state
    let width = canvas.width = Math.min(1000, Math.max(480, innerWidth - 40));
    let height = canvas.height = Math.round(width * 2/3);
    let running = true;
    let aiEnabled = true;
    let leftScore = Number(localStorage.getItem('pong:leftScore') || 0);
    let rightScore = Number(localStorage.getItem('pong:rightScore') || 0);
    updateScoreUI();

    // paddles & ball
    const paddle = { w: Math.max(8, Math.round(width * 0.02)), h: Math.max(60, Math.round(height * 0.15)) };
    const left = { x: 10, y: (height - paddle.h)/2, vy: 0 };
    const right = { x: width - 10 - paddle.w, y: (height - paddle.h)/2, vy: 0 };
    const ball = { x: width/2, y: height/2, vx: 350, vy: 120, r: Math.max(6, Math.round(width * 0.012)) };

    // input
    const keys = {};
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    // resize handling
    function resize() {
      width = canvas.width = Math.min(1000, Math.max(480, innerWidth - 40));
      height = canvas.height = Math.round(width * 2/3);
      paddle.w = Math.max(8, Math.round(width * 0.02));
      paddle.h = Math.max(60, Math.round(height * 0.15));
      left.x = 10;
      right.x = width - 10 - paddle.w;
      ball.r = Math.max(6, Math.round(width * 0.012));
      // clamp paddles
      left.y = Math.min(Math.max(0, left.y), height - paddle.h);
      right.y = Math.min(Math.max(0, right.y), height - paddle.h);
    }
    window.addEventListener('resize', resize);

    // touch controls (drag)
    let ongoingTouch = null;
    function touchToPos(t) {
      const rect = canvas.getBoundingClientRect();
      return { x: t.clientX - rect.left, y: t.clientY - rect.top };
    }
    canvas.addEventListener('touchstart', (ev) => {
      const t = ev.changedTouches[0];
      ongoingTouch = t.identifier;
      const pos = touchToPos(t);
      // move nearest paddle to touch point
      if (pos.x < width/2) left.y = Math.min(Math.max(0, pos.y - paddle.h/2), height - paddle.h);
      else right.y = Math.min(Math.max(0, pos.y - paddle.h/2), height - paddle.h);
      ev.preventDefault();
    }, { passive: false });
    canvas.addEventListener('touchmove', (ev) => {
      for (const t of ev.changedTouches) {
        if (t.identifier === ongoingTouch) {
          const pos = touchToPos(t);
          if (pos.x < width/2) left.y = Math.min(Math.max(0, pos.y - paddle.h/2), height - paddle.h);
          else right.y = Math.min(Math.max(0, pos.y - paddle.h/2), height - paddle.h);
        }
      }
      ev.preventDefault();
    }, { passive: false });
    canvas.addEventListener('touchend', (ev) => { ongoingTouch = null; }, { passive: true });

    // helpers
    function resetBall(servingRight = true) {
      ball.x = width/2;
      ball.y = height/2;
      const speed = Math.max(280, Math.round(width * 0.6));
      ball.vx = (servingRight ? 1 : -1) * speed;
      ball.vy = (Math.random() * 2 - 1) * (speed * 0.35);
    }
    function updateScoreUI() {
      scoreLeftEl.textContent = leftScore;
      scoreRightEl.textContent = rightScore;
    }
    function persistScores() {
      localStorage.setItem('pong:leftScore', String(leftScore));
      localStorage.setItem('pong:rightScore', String(rightScore));
    }

    // physics timestep
    let last = performance.now();
    function frame(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;
      if (running) update(dt);
      render();
      requestAnimationFrame(frame);
    }

    // update game state
    function update(dt) {
      // keyboard left paddle: W/S or ArrowUp/ArrowDown
      const speed = Math.max(300, Math.round(height * 0.9));
      if (keys['w'] || keys['arrowup']) left.y -= speed * dt;
      if (keys['s'] || keys['arrowdown']) left.y += speed * dt;
      left.y = Math.max(0, Math.min(height - paddle.h, left.y));

      // AI for right paddle
      if (aiEnabled) {
        // simple predictive AI
        const target = ball.y + (ball.vy * ((right.x - ball.x) / (ball.vx || 0.0001)));
        const center = right.y + paddle.h/2;
        const dir = target > center ? 1 : -1;
        right.y += dir * speed * 0.6 * dt;
      } else {
        // allow keyboard control for right paddle with I/K keys
        if (keys['i']) right.y -= speed * dt;
        if (keys['k']) right.y += speed * dt;
      }
      right.y = Math.max(0, Math.min(height - paddle.h, right.y));

      // move ball
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // collisions with top/bottom
      if (ball.y - ball.r < 0) {
        ball.y = ball.r;
        ball.vy = -ball.vy;
      } else if (ball.y + ball.r > height) {
        ball.y = height - ball.r;
        ball.vy = -ball.vy;
      }

      // paddle collisions (left)
      if (ball.x - ball.r < left.x + paddle.w &&
          ball.y > left.y &&
          ball.y < left.y + paddle.h &&
          ball.vx < 0) {
        ball.x = left.x + paddle.w + ball.r;
        const relative = (ball.y - (left.y + paddle.h/2)) / (paddle.h/2);
        const bounce = relative * 0.9; // angle factor
        const speedNow = Math.hypot(ball.vx, ball.vy) * 1.03;
        const sign = 1;
        ball.vx = sign * Math.max(220, speedNow) * Math.cos(bounce);
        ball.vy = Math.max(120, speedNow * Math.sin(bounce));
        // ensure x velocity is positive now
        if (ball.vx < 140) ball.vx = 140;
      }

      // paddle collisions (right)
      if (ball.x + ball.r > right.x &&
          ball.y > right.y &&
          ball.y < right.y + paddle.h &&
          ball.vx > 0) {
        ball.x = right.x - ball.r;
        const relative = (ball.y - (right.y + paddle.h/2)) / (paddle.h/2);
        const bounce = relative * 0.9;
        const speedNow = Math.hypot(ball.vx, ball.vy) * 1.03;
        const sign = -1;
        ball.vx = sign * Math.max(220, speedNow) * Math.cos(bounce);
        ball.vy = Math.max(120, speedNow * Math.sin(bounce));
        if (ball.vx > -140) ball.vx = -140;
      }

      // scoring
      if (ball.x < -ball.r) {
        // right scores
        rightScore += 1;
        persistScores();
        updateScoreUI();
        resetBall(true);
      }
      if (ball.x > width + ball.r) {
        // left scores
        leftScore += 1;
        persistScores();
        updateScoreUI();
        resetBall(false);
      }
    }

    // rendering
    function render() {
      // black background
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);

      // center dashed line
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.moveTo(width/2, 0);
      ctx.lineTo(width/2, height);
      ctx.stroke();
      ctx.setLineDash([]);

      // paddles
      ctx.fillStyle = '#eaeaea';
      ctx.fillRect(left.x, left.y, paddle.w, paddle.h);
      ctx.fillRect(right.x, right.y, paddle.w, paddle.h);

      // ball (rounded)
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fill();

      // scores (drawn onto scoreboard elements; we could also draw here)
    }

    // controls
    btnPause.addEventListener('click', () => {
      running = !running;
      btnPause.textContent = running ? 'Pause' : 'Resume';
    });
    btnToggleAI.addEventListener('click', () => {
      aiEnabled = !aiEnabled;
      btnToggleAI.textContent = aiEnabled ? 'AI: ON' : 'AI: OFF';
    });
    btnReset.addEventListener('click', () => {
      leftScore = 0;
      rightScore = 0;
      persistScores();
      updateScoreUI();
    });

    // initialize
    resetBall(true);
    last = performance.now();
    requestAnimationFrame(frame);

    // keep canvas size responsive (call once to match CSS scaling)
    resize();

    // friendly focus hint for keyboard users
    window.addEventListener('keydown', (e) => {
      if (['w','s','arrowup','arrowdown','i','k'].includes(e.key.toLowerCase())) {
        // prevent page scrolling when playing
        e.preventDefault();
      }
    }, { passive: false });
  })();
  </script>
</body>
</html>
